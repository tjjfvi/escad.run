/* esm.sh - esbuild bundle(@babel/core@7.18.2) esnext production */
import __Process$ from "/transpiled/https://esm.sh/v85/node_process.js";
import __debug$ from "/transpiled/https://esm.sh/v85/debug@4.3.4/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/debug.js";
import __fs$ from "/transpiled/https://esm.sh/v85/node_fs.js";
import __gensync$ from "/transpiled/https://esm.sh/v85/gensync@1.0.0-beta.2/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/gensync.js";
import * as ___babel_template$$ from "/transpiled/https://esm.sh/v85/@babel/template@7.16.7/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/template.js";

const ___babel_template$ = Object.assign({
  __esModule: true
}, ___babel_template$$);

import ___babel_parser$ from "/transpiled/https://esm.sh/v85/@babel/parser@7.18.4/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/parser.js";
import ___ampproject_remapping$$ from "/transpiled/https://esm.sh/v85/@ampproject/remapping@2.2.0/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/remapping.js";
import * as ___ampproject_remapping$$$ from "/transpiled/https://esm.sh/v85/@ampproject/remapping@2.2.0/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/remapping.js";

const ___ampproject_remapping$ = Object.assign({
  default: ___ampproject_remapping$$
}, ___ampproject_remapping$$$);

import * as ___babel_helper_compilation_targets$$ from "/transpiled/https://esm.sh/v85/@babel/helper-compilation-targets@7.18.2/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/helper-compilation-targets.js";

const ___babel_helper_compilation_targets$ = Object.assign({
  __esModule: true
}, ___babel_helper_compilation_targets$$);

import ___babel_helper_module_transforms$ from "/transpiled/https://esm.sh/v85/@babel/helper-module-transforms@7.18.0/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/helper-module-transforms.js";
import * as ___babel_code_frame$$ from "/transpiled/https://esm.sh/v85/@babel/code-frame@7.16.7/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/code-frame.js";

const ___babel_code_frame$ = Object.assign({
  __esModule: true
}, ___babel_code_frame$$);

import ___babel_types$ from "/transpiled/https://esm.sh/v85/@babel/types@7.18.4/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/types.js";
import __convert_source_map$ from "/transpiled/https://esm.sh/v85/convert-source-map@1.8.0/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/convert-source-map.js";
import * as ___babel_helpers$$ from "/transpiled/https://esm.sh/v85/@babel/helpers@7.18.2/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/helpers.js";

const ___babel_helpers$ = Object.assign({
  __esModule: true
}, ___babel_helpers$$);

import __path$ from "/transpiled/https://esm.sh/v85/path-browserify@1.0.1/esnext/path-browserify.bundle.js";
import * as ___babel_traverse$$ from "/transpiled/https://esm.sh/v85/@babel/traverse@7.18.2/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/traverse.js";

const ___babel_traverse$ = Object.assign({
  __esModule: true
}, ___babel_traverse$$);

import * as ___babel_generator$$ from "/transpiled/https://esm.sh/v85/@babel/generator@7.18.2/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/generator.js";

const ___babel_generator$ = Object.assign({
  __esModule: true
}, ___babel_generator$$);

import __semver$ from "/transpiled/https://esm.sh/v85/semver@6.3.0/X-YS9AYmFiZWwvaGlnaGxpZ2h0OmJhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbQpkL2JhYmVsLWhpZ2hsaWdodC1lc20tc2gtc2hpbUAwLjAuMg/esnext/semver.js";
var ko = Object.create;
var ot = Object.defineProperty;
var jo = Object.getOwnPropertyDescriptor;
var xo = Object.getOwnPropertyNames;
var Fo = Object.getPrototypeOf,
    Mo = Object.prototype.hasOwnProperty;

var o = (e, t) => ot(e, "name", {
  value: t,
  configurable: !0
}),
    p = (e => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (t, r) => (typeof require != "undefined" ? require : t)[r]
}) : e)(function (e) {
  if (typeof require != "undefined") return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});

var g = (e, t) => () => (t || e((t = {
  exports: {}
}).exports, t), t.exports);

var $o = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function") for (let s of xo(t)) !Mo.call(e, s) && s !== r && ot(e, s, {
    get: () => t[s],
    enumerable: !(n = jo(t, s)) || n.enumerable
  });
  return e;
};

var hr = (e, t, r) => (r = e != null ? ko(Fo(e)) : {}, $o(t || !e || !e.__esModule ? ot(r, "default", {
  value: e,
  enumerable: !0
}) : r, e));

var Se = g(Ce => {
  "use strict";

  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.default = void 0;

  function re() {
    let e = ___babel_helpers$;
    return re = o(function () {
      return e;
    }, "helpers"), e;
  }

  o(re, "helpers");

  function st() {
    let e = ___babel_traverse$;
    return st = o(function () {
      return e;
    }, "_traverse"), e;
  }

  o(st, "_traverse");

  function yr() {
    let e = ___babel_code_frame$;
    return yr = o(function () {
      return e;
    }, "_codeFrame"), e;
  }

  o(yr, "_codeFrame");

  function vr() {
    let e = ___babel_types$;
    return vr = o(function () {
      return e;
    }, "_t"), e;
  }

  o(vr, "_t");

  function wr() {
    let e = ___babel_helper_module_transforms$;
    return wr = o(function () {
      return e;
    }, "_helperModuleTransforms"), e;
  }

  o(wr, "_helperModuleTransforms");

  function Ee() {
    let e = __semver$;
    return Ee = o(function () {
      return e;
    }, "_semver"), e;
  }

  o(Ee, "_semver");
  var {
    cloneNode: No,
    interpreterDirective: Io
  } = vr(),
      qo = {
    enter(e, t) {
      let r = e.node.loc;
      r && (t.loc = r, e.stop());
    }

  },
      J = class {
    constructor(t, {
      code: r,
      ast: n,
      inputMap: s
    }) {
      this._map = new Map(), this.opts = void 0, this.declarations = {}, this.path = null, this.ast = {}, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = null, this.hub = {
        file: this,
        getCode: () => this.code,
        getScope: () => this.scope,
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = t, this.code = r, this.ast = n, this.inputMap = s, this.path = st().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }

    get shebang() {
      let {
        interpreter: t
      } = this.path.node;
      return t ? t.value : "";
    }

    set shebang(t) {
      t ? this.path.get("interpreter").replaceWith(Io(t)) : this.path.get("interpreter").remove();
    }

    set(t, r) {
      if (t === "helpersNamespace") throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");

      this._map.set(t, r);
    }

    get(t) {
      return this._map.get(t);
    }

    has(t) {
      return this._map.has(t);
    }

    getModuleName() {
      return (0, wr().getModuleName)(this.opts, this.opts);
    }

    addImport() {
      throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }

    availableHelper(t, r) {
      let n;

      try {
        n = re().minVersion(t);
      } catch (s) {
        if (s.code !== "BABEL_HELPER_UNKNOWN") throw s;
        return !1;
      }

      return typeof r != "string" ? !0 : (Ee().valid(r) && (r = `^${r}`), !Ee().intersects(`<${n}`, r) && !Ee().intersects(">=8.0.0", r));
    }

    addHelper(t) {
      let r = this.declarations[t];
      if (r) return No(r);
      let n = this.get("helperGenerator");

      if (n) {
        let l = n(t);
        if (l) return l;
      }

      re().ensure(t, J);
      let s = this.declarations[t] = this.scope.generateUidIdentifier(t),
          i = {};

      for (let l of re().getDependencies(t)) i[l] = this.addHelper(l);

      let {
        nodes: a,
        globals: u
      } = re().get(t, l => i[l], s, Object.keys(this.scope.getAllBindings()));
      return u.forEach(l => {
        this.path.scope.hasBinding(l, !0) && this.path.scope.rename(l);
      }), a.forEach(l => {
        l._compact = !0;
      }), this.path.unshiftContainer("body", a), this.path.get("body").forEach(l => {
        a.indexOf(l.node) !== -1 && l.isVariableDeclaration() && this.scope.registerDeclaration(l);
      }), s;
    }

    addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }

    buildCodeFrameError(t, r, n = SyntaxError) {
      let s = t && (t.loc || t._loc);

      if (!s && t) {
        let i = {
          loc: null
        };
        (0, st().default)(t, qo, this.scope, i), s = i.loc;
        let a = "This is an error on an internal node. Probably an internal error.";
        s && (a += " Location has been estimated."), r += ` (${a})`;
      }

      if (s) {
        let {
          highlightCode: i = !0
        } = this.opts;
        r += `
` + (0, yr().codeFrameColumns)(this.code, {
          start: {
            line: s.start.line,
            column: s.start.column + 1
          },
          end: s.end && s.start.line === s.end.line ? {
            line: s.end.line,
            column: s.end.column + 1
          } : void 0
        }, {
          highlightCode: i
        });
      }

      return new n(r);
    }

  };
  o(J, "File");
  Ce.default = J;
});
var Ar = g(ct => {
  "use strict";

  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.default = Zo;

  function Ae() {
    let e = ___babel_helpers$;
    return Ae = o(function () {
      return e;
    }, "helpers"), e;
  }

  o(Ae, "helpers");

  function _r() {
    let e = ___babel_generator$;
    return _r = o(function () {
      return e;
    }, "_generator"), e;
  }

  o(_r, "_generator");

  function Or() {
    let e = ___babel_template$;
    return Or = o(function () {
      return e;
    }, "_template"), e;
  }

  o(Or, "_template");

  function Pr() {
    let e = ___babel_types$;
    return Pr = o(function () {
      return e;
    }, "_t"), e;
  }

  o(Pr, "_t");
  var Do = Se(),
      {
    arrayExpression: Ro,
    assignmentExpression: Er,
    binaryExpression: To,
    blockStatement: Bo,
    callExpression: Lo,
    cloneNode: Uo,
    conditionalExpression: Wo,
    exportNamedDeclaration: Ho,
    exportSpecifier: Vo,
    expressionStatement: Cr,
    functionExpression: Go,
    identifier: k,
    memberExpression: it,
    objectExpression: at,
    program: ke,
    stringLiteral: Sr,
    unaryExpression: zo,
    variableDeclaration: ut,
    variableDeclarator: lt
  } = Pr(),
      Jo = o(e => Or().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e), "buildUmdWrapper");

  function Yo(e) {
    let t = k("babelHelpers"),
        r = [],
        n = Go(null, [k("global")], Bo(r)),
        s = ke([Cr(Lo(n, [Wo(To("===", zo("typeof", k("global")), Sr("undefined")), k("self"), k("global"))]))]);
    return r.push(ut("var", [lt(t, Er("=", it(k("global"), t), at([])))])), je(r, t, e), s;
  }

  o(Yo, "buildGlobal");

  function Ko(e) {
    let t = [],
        r = je(t, null, e);
    return t.unshift(Ho(null, Object.keys(r).map(n => Vo(Uo(r[n]), k(n))))), ke(t, [], "module");
  }

  o(Ko, "buildModule");

  function Xo(e) {
    let t = k("babelHelpers"),
        r = [];
    return r.push(ut("var", [lt(t, k("global"))])), je(r, t, e), ke([Jo({
      FACTORY_PARAMETERS: k("global"),
      BROWSER_ARGUMENTS: Er("=", it(k("root"), t), at([])),
      COMMON_ARGUMENTS: k("exports"),
      AMD_ARGUMENTS: Ro([Sr("exports")]),
      FACTORY_BODY: r,
      UMD_ROOT: k("this")
    })]);
  }

  o(Xo, "buildUmd");

  function Qo(e) {
    let t = k("babelHelpers"),
        r = [];
    r.push(ut("var", [lt(t, at([]))]));
    let n = ke(r);
    return je(r, t, e), r.push(Cr(t)), n;
  }

  o(Qo, "buildVar");

  function je(e, t, r) {
    let n = o(i => t ? it(t, k(i)) : k(`_${i}`), "getHelperReference"),
        s = {};
    return Ae().list.forEach(function (i) {
      if (r && r.indexOf(i) < 0) return;
      let a = s[i] = n(i);
      Ae().ensure(i, Do.default);
      let {
        nodes: u
      } = Ae().get(i, n, a);
      e.push(...u);
    }), s;
  }

  o(je, "buildHelpers");

  function Zo(e, t = "global") {
    let r,
        n = {
      global: Yo,
      module: Ko,
      umd: Xo,
      var: Qo
    }[t];
    if (n) r = n(e);else throw new Error(`Unsupported output type ${t}`);
    return (0, _r().default)(r).code;
  }

  o(Zo, "_default");
});
var ne = g(j => {
  "use strict";

  Object.defineProperty(j, "__esModule", {
    value: !0
  });
  j.ROOT_CONFIG_FILENAMES = void 0;
  j.findConfigUpwards = es;
  j.findPackageData = ts;
  j.findRelativeConfig = rs;
  j.findRootConfig = ns;
  j.loadConfig = os;
  j.loadPlugin = ls;
  j.loadPreset = cs;
  j.resolvePlugin = as;
  j.resolvePreset = us;
  j.resolveShowConfigPath = ss;

  function es(e) {
    return null;
  }

  o(es, "findConfigUpwards");

  function* ts(e) {
    return {
      filepath: e,
      directories: [],
      pkg: null,
      isPackage: !1
    };
  }

  o(ts, "findPackageData");

  function* rs(e, t, r) {
    return {
      config: null,
      ignore: null
    };
  }

  o(rs, "findRelativeConfig");

  function* ns(e, t, r) {
    return null;
  }

  o(ns, "findRootConfig");

  function* os(e, t, r, n) {
    throw new Error(`Cannot load ${e} relative to ${t} in a browser`);
  }

  o(os, "loadConfig");

  function* ss(e) {
    return null;
  }

  o(ss, "resolveShowConfigPath");
  var is = [];
  j.ROOT_CONFIG_FILENAMES = is;

  function as(e, t) {
    return null;
  }

  o(as, "resolvePlugin");

  function us(e, t) {
    return null;
  }

  o(us, "resolvePreset");

  function ls(e, t) {
    throw new Error(`Cannot load plugin ${e} relative to ${t} in a browser`);
  }

  o(ls, "loadPlugin");

  function cs(e, t) {
    throw new Error(`Cannot load preset ${e} relative to ${t} in a browser`);
  }

  o(cs, "loadPreset");
});
var pt = g(ft => {
  "use strict";

  Object.defineProperty(ft, "__esModule", {
    value: !0
  });
  ft.getEnv = fs;

  function fs(e = "development") {
    return __Process$.env.BABEL_ENV || "production";
  }

  o(fs, "getEnv");
});
var dt = g(N => {
  "use strict";

  Object.defineProperty(N, "__esModule", {
    value: !0
  });
  N.forwardAsync = gs;
  N.isAsync = void 0;
  N.isThenable = xr;
  N.maybeAsync = ds;
  N.waitFor = N.onFirstPause = void 0;

  function L() {
    let e = __gensync$;
    return L = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(L, "_gensync");
  var kr = o(e => e, "id"),
      jr = L()(function* (e) {
    return yield* e;
  }),
      ps = L()({
    sync: () => !1,
    errback: e => e(null, !0)
  });
  N.isAsync = ps;

  function ds(e, t) {
    return L()({
      sync(...r) {
        let n = e.apply(this, r);
        if (xr(n)) throw new Error(t);
        return n;
      },

      async(...r) {
        return Promise.resolve(e.apply(this, r));
      }

    });
  }

  o(ds, "maybeAsync");
  var bs = L()({
    sync: e => e("sync"),
    async: e => e("async")
  });

  function gs(e, t) {
    let r = L()(e);
    return bs(n => {
      let s = r[n];
      return t(s);
    });
  }

  o(gs, "forwardAsync");
  var ms = L()({
    name: "onFirstPause",
    arity: 2,
    sync: function (e) {
      return jr.sync(e);
    },
    errback: function (e, t, r) {
      let n = !1;
      jr.errback(e, (s, i) => {
        n = !0, r(s, i);
      }), n || t();
    }
  });
  N.onFirstPause = ms;
  var hs = L()({
    sync: kr,
    async: kr
  });
  N.waitFor = hs;

  function xr(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }

  o(xr, "isThenable");
});
var Fe = g(xe => {
  "use strict";

  Object.defineProperty(xe, "__esModule", {
    value: !0
  });
  xe.isIterableIterator = ws;
  xe.mergeOptions = ys;

  function ys(e, t) {
    for (let r of Object.keys(t)) if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
      let n = t[r],
          s = e[r] || (e[r] = {});
      vs(s, n);
    } else {
      let n = t[r];
      n !== void 0 && (e[r] = n);
    }
  }

  o(ys, "mergeOptions");

  function vs(e, t) {
    for (let r of Object.keys(t)) {
      let n = t[r];
      n !== void 0 && (e[r] = n);
    }
  }

  o(vs, "mergeDefaultFields");

  function ws(e) {
    return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
  }

  o(ws, "isIterableIterator");
});
var $e = g(Me => {
  "use strict";

  Object.defineProperty(Me, "__esModule", {
    value: !0
  });
  Me.finalize = _s;
  Me.flattenToSet = Os;

  function _s(e) {
    return Object.freeze(e);
  }

  o(_s, "finalize");

  function Os(e) {
    let t = new Set(),
        r = [e];

    for (; r.length > 0;) for (let n of r.pop()) Array.isArray(n) ? r.push(n) : t.add(n);

    return t;
  }

  o(Os, "flattenToSet");
});
var oe = g(Ie => {
  "use strict";

  Object.defineProperty(Ie, "__esModule", {
    value: !0
  });
  Ie.default = void 0;
  var Ps = $e(),
      Ne = class {
    constructor(t, r, n, s = (0, Ps.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || n, this.manipulateOptions = t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = s;
    }

  };
  o(Ne, "Plugin");
  Ie.default = Ne;
});
var se = g(V => {
  "use strict";

  Object.defineProperty(V, "__esModule", {
    value: !0
  });
  V.assertSimpleType = De;
  V.makeStrongCache = Ir;
  V.makeStrongCacheSync = As;
  V.makeWeakCache = Nr;
  V.makeWeakCacheSync = Ss;

  function Mr() {
    let e = __gensync$;
    return Mr = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(Mr, "_gensync");
  var Y = dt(),
      Es = Fe(),
      $r = o(e => Mr()(e).sync, "synchronize");

  function* Cs() {
    return !0;
  }

  o(Cs, "genTrue");

  function Nr(e) {
    return qr(WeakMap, e);
  }

  o(Nr, "makeWeakCache");

  function Ss(e) {
    return $r(Nr(e));
  }

  o(Ss, "makeWeakCacheSync");

  function Ir(e) {
    return qr(Map, e);
  }

  o(Ir, "makeStrongCache");

  function As(e) {
    return $r(Ir(e));
  }

  o(As, "makeStrongCacheSync");

  function qr(e, t) {
    let r = new e(),
        n = new e(),
        s = new e();
    return o(function* (a, u) {
      let l = yield* (0, Y.isAsync)(),
          f = l ? n : r,
          d = yield* ks(l, f, s, a, u);
      if (d.valid) return d.value;
      let y = new qe(u),
          w = t(a, y),
          v,
          m;

      if ((0, Es.isIterableIterator)(w)) {
        let P = w;
        m = yield* (0, Y.onFirstPause)(P, () => {
          v = js(y, s, a);
        });
      } else m = w;

      return Dr(f, y, a, m), v && (s.delete(a), v.release(m)), m;
    }, "cachedFunction");
  }

  o(qr, "makeCachedFunction");

  function* Fr(e, t, r) {
    let n = e.get(t);

    if (n) {
      for (let {
        value: s,
        valid: i
      } of n) if (yield* i(r)) return {
        valid: !0,
        value: s
      };
    }

    return {
      valid: !1,
      value: null
    };
  }

  o(Fr, "getCachedValue");

  function* ks(e, t, r, n, s) {
    let i = yield* Fr(t, n, s);
    if (i.valid) return i;

    if (e) {
      let a = yield* Fr(r, n, s);

      if (a.valid) {
        let u = yield* (0, Y.waitFor)(a.value.promise);
        return {
          valid: !0,
          value: u
        };
      }
    }

    return {
      valid: !1,
      value: null
    };
  }

  o(ks, "getCachedValueOrWait");

  function js(e, t, r) {
    let n = new Re();
    return Dr(t, e, r, n), n;
  }

  o(js, "setupAsyncLocks");

  function Dr(e, t, r, n) {
    t.configured() || t.forever();
    let s = e.get(r);

    switch (t.deactivate(), t.mode()) {
      case "forever":
        s = [{
          value: n,
          valid: Cs
        }], e.set(r, s);
        break;

      case "invalidate":
        s = [{
          value: n,
          valid: t.validator()
        }], e.set(r, s);
        break;

      case "valid":
        s ? s.push({
          value: n,
          valid: t.validator()
        }) : (s = [{
          value: n,
          valid: t.validator()
        }], e.set(r, s));
    }
  }

  o(Dr, "updateFunctionCache");
  var qe = class {
    constructor(t) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0, this._data = t;
    }

    simple() {
      return xs(this);
    }

    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }

    forever() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never) throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }

    never() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever) throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }

    using(t) {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let r = t(this._data),
          n = (0, Y.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronously");
      return (0, Y.isThenable)(r) ? r.then(s => (this._pairs.push([s, n]), s)) : (this._pairs.push([r, n]), r);
    }

    invalidate(t) {
      return this._invalidate = !0, this.using(t);
    }

    validator() {
      let t = this._pairs;
      return function* (r) {
        for (let [n, s] of t) if (n !== (yield* s(r))) return !1;

        return !0;
      };
    }

    deactivate() {
      this._active = !1;
    }

    configured() {
      return this._configured;
    }

  };
  o(qe, "CacheConfigurator");

  function xs(e) {
    function t(r) {
      if (typeof r == "boolean") {
        r ? e.forever() : e.never();
        return;
      }

      return e.using(() => De(r()));
    }

    return o(t, "cacheFn"), t.forever = () => e.forever(), t.never = () => e.never(), t.using = r => e.using(() => De(r())), t.invalidate = r => e.invalidate(() => De(r())), t;
  }

  o(xs, "makeSimpleConfigurator");

  function De(e) {
    if ((0, Y.isThenable)(e)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
    if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number") throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e;
  }

  o(De, "assertSimpleType");
  var Re = class {
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise(t => {
        this._resolve = t;
      });
    }

    release(t) {
      this.released = !0, this._resolve(t);
    }

  };
  o(Re, "Lock");
});
var bt = g(Te => {
  "use strict";

  Object.defineProperty(Te, "__esModule", {
    value: !0
  });
  Te.resolveBrowserslistConfigFile = Fs;
  Te.resolveTargets = Ms;

  function Rr() {
    let e = ___babel_helper_compilation_targets$;
    return Rr = o(function () {
      return e;
    }, "_helperCompilationTargets"), e;
  }

  o(Rr, "_helperCompilationTargets");

  function Fs(e, t) {}

  o(Fs, "resolveBrowserslistConfigFile");

  function Ms(e, t) {
    let r = e.targets;
    return (typeof r == "string" || Array.isArray(r)) && (r = {
      browsers: r
    }), r && r.esmodules && (r = Object.assign({}, r, {
      esmodules: "intersect"
    })), (0, Rr().default)(r, {
      ignoreBrowserslistConfig: !0,
      browserslistEnv: e.browserslistEnv
    });
  }

  o(Ms, "resolveTargets");
});
var gt = g(ae => {
  "use strict";

  Object.defineProperty(ae, "__esModule", {
    value: !0
  });
  ae.createCachedDescriptors = qs;
  ae.createDescriptor = zr;
  ae.createUncachedDescriptors = Ds;

  function Lr() {
    let e = __gensync$;
    return Lr = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(Lr, "_gensync");
  var Tr = ne(),
      $s = ue(),
      ie = se(),
      Ns = bt();

  function Is(e, t) {
    return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass === t.ownPass && (e.file && e.file.request) === (t.file && t.file.request) && (e.file && e.file.resolved) === (t.file && t.file.resolved);
  }

  o(Is, "isEqualDescriptor");

  function* Br(e) {
    return e;
  }

  o(Br, "handlerOf");

  function Ur(e, t) {
    return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, Ns.resolveBrowserslistConfigFile)(e.browserslistConfigFile, t)), e;
  }

  o(Ur, "optionsWithResolvedBrowserslistConfigFile");

  function qs(e, t, r) {
    let {
      plugins: n,
      presets: s,
      passPerPreset: i
    } = t;
    return {
      options: Ur(t, e),
      plugins: n ? () => Ls(n, e)(r) : () => Br([]),
      presets: s ? () => Ts(s, e)(r)(!!i) : () => Br([])
    };
  }

  o(qs, "createCachedDescriptors");

  function Ds(e, t, r) {
    let n, s;
    return {
      options: Ur(t, e),

      *plugins() {
        return n || (n = yield* Vr(t.plugins || [], e, r)), n;
      },

      *presets() {
        return s || (s = yield* Hr(t.presets || [], e, r, !!t.passPerPreset)), s;
      }

    };
  }

  o(Ds, "createUncachedDescriptors");
  var Rs = new WeakMap(),
      Ts = (0, ie.makeWeakCacheSync)((e, t) => {
    let r = t.using(n => n);
    return (0, ie.makeStrongCacheSync)(n => (0, ie.makeStrongCache)(function* (s) {
      return (yield* Hr(e, r, n, s)).map(a => Wr(Rs, a));
    }));
  }),
      Bs = new WeakMap(),
      Ls = (0, ie.makeWeakCacheSync)((e, t) => {
    let r = t.using(n => n);
    return (0, ie.makeStrongCache)(function* (n) {
      return (yield* Vr(e, r, n)).map(i => Wr(Bs, i));
    });
  }),
      Us = {};

  function Wr(e, t) {
    let {
      value: r,
      options: n = Us
    } = t;
    if (n === !1) return t;
    let s = e.get(r);
    s || (s = new WeakMap(), e.set(r, s));
    let i = s.get(n);

    if (i || (i = [], s.set(n, i)), i.indexOf(t) === -1) {
      let a = i.filter(u => Is(u, t));
      if (a.length > 0) return a[0];
      i.push(t);
    }

    return t;
  }

  o(Wr, "loadCachedDescriptor");

  function* Hr(e, t, r, n) {
    return yield* Gr("preset", e, t, r, n);
  }

  o(Hr, "createPresetDescriptors");

  function* Vr(e, t, r) {
    return yield* Gr("plugin", e, t, r);
  }

  o(Vr, "createPluginDescriptors");

  function* Gr(e, t, r, n, s) {
    let i = yield* Lr().all(t.map((a, u) => zr(a, r, {
      type: e,
      alias: `${n}$${u}`,
      ownPass: !!s
    })));
    return Ws(i), i;
  }

  o(Gr, "createDescriptors");

  function* zr(e, t, {
    type: r,
    alias: n,
    ownPass: s
  }) {
    let i = (0, $s.getItemDescriptor)(e);
    if (i) return i;
    let a,
        u,
        l = e;
    Array.isArray(l) && (l.length === 3 ? [l, u, a] = l : [l, u] = l);
    let f,
        d = null;

    if (typeof l == "string") {
      if (typeof r != "string") throw new Error("To resolve a string-based item, the type of item must be given");
      let y = r === "plugin" ? Tr.loadPlugin : Tr.loadPreset,
          w = l;
      ({
        filepath: d,
        value: l
      } = yield* y(l, t)), f = {
        request: w,
        resolved: d
      };
    }

    if (!l) throw new Error(`Unexpected falsy value: ${String(l)}`);
    if (typeof l == "object" && l.__esModule) if (l.default) l = l.default;else throw new Error("Must export a default export when using ES6 modules.");
    if (typeof l != "object" && typeof l != "function") throw new Error(`Unsupported format: ${typeof l}. Expected an object or a function.`);
    if (d !== null && typeof l == "object" && l) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${d}`);
    return {
      name: a,
      alias: d || n,
      value: l,
      options: u,
      dirname: t,
      ownPass: s,
      file: f
    };
  }

  o(zr, "createDescriptor");

  function Ws(e) {
    let t = new Map();

    for (let r of e) {
      if (typeof r.value != "function") continue;
      let n = t.get(r.value);

      if (n || (n = new Set(), t.set(r.value, n)), n.has(r.name)) {
        let s = e.filter(i => i.value === r.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(s, null, 2)}`].join(`
`));
      }

      n.add(r.name);
    }
  }

  o(Ws, "assertNoDuplicates");
});
var ue = g(ce => {
  "use strict";

  Object.defineProperty(ce, "__esModule", {
    value: !0
  });
  ce.createConfigItem = Vs;
  ce.createItemFromDescriptor = Yr;
  ce.getItemDescriptor = Gs;

  function Jr() {
    let e = __path$;
    return Jr = o(function () {
      return e;
    }, "_path"), e;
  }

  o(Jr, "_path");
  var Hs = gt();

  function Yr(e) {
    return new le(e);
  }

  o(Yr, "createItemFromDescriptor");

  function* Vs(e, {
    dirname: t = ".",
    type: r
  } = {}) {
    let n = yield* (0, Hs.createDescriptor)(e, Jr().resolve(t), {
      type: r,
      alias: "programmatic item"
    });
    return Yr(n);
  }

  o(Vs, "createConfigItem");

  function Gs(e) {
    if (e != null && e[mt]) return e._descriptor;
  }

  o(Gs, "getItemDescriptor");
  var mt = Symbol.for("@babel/core@7 - ConfigItem"),
      le = class {
    constructor(t) {
      this._descriptor = void 0, this[mt] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, mt, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }

  };
  o(le, "ConfigItem");
  Object.freeze(le.prototype);
});
var Kr = g(Be => {
  "use strict";

  Object.defineProperty(Be, "__esModule", {
    value: !0
  });
  Be.default = void 0;
  var zs = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
    }
  };
  Be.default = zs;
});
var vt = g(O => {
  "use strict";

  Object.defineProperty(O, "__esModule", {
    value: !0
  });
  O.access = x;
  O.assertArray = yt;
  O.assertAssumptions = pi;
  O.assertBabelrcSearch = ai;
  O.assertBoolean = ht;
  O.assertCallerMetadata = Zs;
  O.assertCompact = Xs;
  O.assertConfigApplicableTest = si;
  O.assertConfigFileSearch = ii;
  O.assertFunction = ri;
  O.assertIgnoreList = ni;
  O.assertInputSourceMap = ei;
  O.assertObject = Zr;
  O.assertPluginList = ui;
  O.assertRootMode = Ys;
  O.assertSourceMaps = Ks;
  O.assertSourceType = Qs;
  O.assertString = ti;
  O.assertTargets = ci;
  O.msg = h;

  function fe() {
    let e = ___babel_helper_compilation_targets$;
    return fe = o(function () {
      return e;
    }, "_helperCompilationTargets"), e;
  }

  o(fe, "_helperCompilationTargets");
  var Js = pe();

  function h(e) {
    switch (e.type) {
      case "root":
        return "";

      case "env":
        return `${h(e.parent)}.env["${e.name}"]`;

      case "overrides":
        return `${h(e.parent)}.overrides[${e.index}]`;

      case "option":
        return `${h(e.parent)}.${e.name}`;

      case "access":
        return `${h(e.parent)}[${JSON.stringify(e.name)}]`;

      default:
        throw new Error(`Assertion failure: Unknown type ${e.type}`);
    }
  }

  o(h, "msg");

  function x(e, t) {
    return {
      type: "access",
      name: t,
      parent: e
    };
  }

  o(x, "access");

  function Ys(e, t) {
    if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional") throw new Error(`${h(e)} must be a "root", "upward", "upward-optional" or undefined`);
    return t;
  }

  o(Ys, "assertRootMode");

  function Ks(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both") throw new Error(`${h(e)} must be a boolean, "inline", "both", or undefined`);
    return t;
  }

  o(Ks, "assertSourceMaps");

  function Xs(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "auto") throw new Error(`${h(e)} must be a boolean, "auto", or undefined`);
    return t;
  }

  o(Xs, "assertCompact");

  function Qs(e, t) {
    if (t !== void 0 && t !== "module" && t !== "script" && t !== "unambiguous") throw new Error(`${h(e)} must be "module", "script", "unambiguous", or undefined`);
    return t;
  }

  o(Qs, "assertSourceType");

  function Zs(e, t) {
    let r = Zr(e, t);

    if (r) {
      if (typeof r.name != "string") throw new Error(`${h(e)} set but does not contain "name" property string`);

      for (let n of Object.keys(r)) {
        let s = x(e, n),
            i = r[n];
        if (i != null && typeof i != "boolean" && typeof i != "string" && typeof i != "number") throw new Error(`${h(s)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }

    return t;
  }

  o(Zs, "assertCallerMetadata");

  function ei(e, t) {
    if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t)) throw new Error(`${h(e)} must be a boolean, object, or undefined`);
    return t;
  }

  o(ei, "assertInputSourceMap");

  function ti(e, t) {
    if (t !== void 0 && typeof t != "string") throw new Error(`${h(e)} must be a string, or undefined`);
    return t;
  }

  o(ti, "assertString");

  function ri(e, t) {
    if (t !== void 0 && typeof t != "function") throw new Error(`${h(e)} must be a function, or undefined`);
    return t;
  }

  o(ri, "assertFunction");

  function ht(e, t) {
    if (t !== void 0 && typeof t != "boolean") throw new Error(`${h(e)} must be a boolean, or undefined`);
    return t;
  }

  o(ht, "assertBoolean");

  function Zr(e, t) {
    if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t)) throw new Error(`${h(e)} must be an object, or undefined`);
    return t;
  }

  o(Zr, "assertObject");

  function yt(e, t) {
    if (t != null && !Array.isArray(t)) throw new Error(`${h(e)} must be an array, or undefined`);
    return t;
  }

  o(yt, "assertArray");

  function ni(e, t) {
    let r = yt(e, t);
    return r && r.forEach((n, s) => oi(x(e, s), n)), r;
  }

  o(ni, "assertIgnoreList");

  function oi(e, t) {
    if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp)) throw new Error(`${h(e)} must be an array of string/Function/RegExp values, or undefined`);
    return t;
  }

  o(oi, "assertIgnoreItem");

  function si(e, t) {
    if (t === void 0) return t;
    if (Array.isArray(t)) t.forEach((r, n) => {
      if (!Le(r)) throw new Error(`${h(x(e, n))} must be a string/Function/RegExp.`);
    });else if (!Le(t)) throw new Error(`${h(e)} must be a string/Function/RegExp, or an array of those`);
    return t;
  }

  o(si, "assertConfigApplicableTest");

  function Le(e) {
    return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
  }

  o(Le, "checkValidTest");

  function ii(e, t) {
    if (t !== void 0 && typeof t != "boolean" && typeof t != "string") throw new Error(`${h(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
    return t;
  }

  o(ii, "assertConfigFileSearch");

  function ai(e, t) {
    if (t === void 0 || typeof t == "boolean") return t;
    if (Array.isArray(t)) t.forEach((r, n) => {
      if (!Le(r)) throw new Error(`${h(x(e, n))} must be a string/Function/RegExp.`);
    });else if (!Le(t)) throw new Error(`${h(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
    return t;
  }

  o(ai, "assertBabelrcSearch");

  function ui(e, t) {
    let r = yt(e, t);
    return r && r.forEach((n, s) => li(x(e, s), n)), r;
  }

  o(ui, "assertPluginList");

  function li(e, t) {
    if (Array.isArray(t)) {
      if (t.length === 0) throw new Error(`${h(e)} must include an object`);
      if (t.length > 3) throw new Error(`${h(e)} may only be a two-tuple or three-tuple`);

      if (Xr(x(e, 0), t[0]), t.length > 1) {
        let r = t[1];
        if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null)) throw new Error(`${h(x(e, 1))} must be an object, false, or undefined`);
      }

      if (t.length === 3) {
        let r = t[2];
        if (r !== void 0 && typeof r != "string") throw new Error(`${h(x(e, 2))} must be a string, or undefined`);
      }
    } else Xr(e, t);

    return t;
  }

  o(li, "assertPluginItem");

  function Xr(e, t) {
    if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function") throw new Error(`${h(e)} must be a string, object, function`);
    return t;
  }

  o(Xr, "assertPluginTarget");

  function ci(e, t) {
    if ((0, fe().isBrowsersQueryValid)(t)) return t;
    if (typeof t != "object" || !t || Array.isArray(t)) throw new Error(`${h(e)} must be a string, an array of strings or an object`);
    let r = x(e, "browsers"),
        n = x(e, "esmodules");
    Qr(r, t.browsers), ht(n, t.esmodules);

    for (let s of Object.keys(t)) {
      let i = t[s],
          a = x(e, s);
      if (s === "esmodules") ht(a, i);else if (s === "browsers") Qr(a, i);else if (Object.hasOwnProperty.call(fe().TargetNames, s)) fi(a, i);else {
        let u = Object.keys(fe().TargetNames).join(", ");
        throw new Error(`${h(a)} is not a valid target. Supported targets are ${u}`);
      }
    }

    return t;
  }

  o(ci, "assertTargets");

  function Qr(e, t) {
    if (t !== void 0 && !(0, fe().isBrowsersQueryValid)(t)) throw new Error(`${h(e)} must be undefined, a string or an array of strings`);
  }

  o(Qr, "assertBrowsersList");

  function fi(e, t) {
    if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string") throw new Error(`${h(e)} must be a string or an integer number`);
  }

  o(fi, "assertBrowserVersion");

  function pi(e, t) {
    if (t === void 0) return;
    if (typeof t != "object" || t === null) throw new Error(`${h(e)} must be an object or undefined.`);
    let r = e;

    do r = r.parent; while (r.type !== "root");

    let n = r.source === "preset";

    for (let s of Object.keys(t)) {
      let i = x(e, s);
      if (!Js.assumptionsNames.has(s)) throw new Error(`${h(i)} is not a supported assumption.`);
      if (typeof t[s] != "boolean") throw new Error(`${h(i)} must be a boolean.`);
      if (n && t[s] === !1) throw new Error(`${h(i)} cannot be set to 'false' inside presets.`);
    }

    return t;
  }

  o(pi, "assertAssumptions");
});
var pe = g(K => {
  "use strict";

  Object.defineProperty(K, "__esModule", {
    value: !0
  });
  K.assumptionsNames = void 0;
  K.checkNoUnwrappedItemOptionPairs = wi;
  K.validate = gi;
  var Vu = oe(),
      en = Kr(),
      c = vt(),
      tn = {
    cwd: c.assertString,
    root: c.assertString,
    rootMode: c.assertRootMode,
    configFile: c.assertConfigFileSearch,
    caller: c.assertCallerMetadata,
    filename: c.assertString,
    filenameRelative: c.assertString,
    code: c.assertBoolean,
    ast: c.assertBoolean,
    cloneInputAst: c.assertBoolean,
    envName: c.assertString
  },
      rn = {
    babelrc: c.assertBoolean,
    babelrcRoots: c.assertBabelrcSearch
  },
      nn = {
    extends: c.assertString,
    ignore: c.assertIgnoreList,
    only: c.assertIgnoreList,
    targets: c.assertTargets,
    browserslistConfigFile: c.assertConfigFileSearch,
    browserslistEnv: c.assertString
  },
      sn = {
    inputSourceMap: c.assertInputSourceMap,
    presets: c.assertPluginList,
    plugins: c.assertPluginList,
    passPerPreset: c.assertBoolean,
    assumptions: c.assertAssumptions,
    env: yi,
    overrides: vi,
    test: c.assertConfigApplicableTest,
    include: c.assertConfigApplicableTest,
    exclude: c.assertConfigApplicableTest,
    retainLines: c.assertBoolean,
    comments: c.assertBoolean,
    shouldPrintComment: c.assertFunction,
    compact: c.assertCompact,
    minified: c.assertBoolean,
    auxiliaryCommentBefore: c.assertString,
    auxiliaryCommentAfter: c.assertString,
    sourceType: c.assertSourceType,
    wrapPluginVisitorMethod: c.assertFunction,
    highlightCode: c.assertBoolean,
    sourceMaps: c.assertSourceMaps,
    sourceMap: c.assertSourceMaps,
    sourceFileName: c.assertString,
    sourceRoot: c.assertString,
    parserOpts: c.assertObject,
    generatorOpts: c.assertObject
  };
  Object.assign(sn, {
    getModuleId: c.assertFunction,
    moduleRoot: c.assertString,
    moduleIds: c.assertBoolean,
    moduleId: c.assertString
  });
  var di = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"],
      bi = new Set(di);
  K.assumptionsNames = bi;

  function an(e) {
    return e.type === "root" ? e.source : an(e.parent);
  }

  o(an, "getSource");

  function gi(e, t) {
    return wt({
      type: "root",
      source: e
    }, t);
  }

  o(gi, "validate");

  function wt(e, t) {
    let r = an(e);
    return hi(t), Object.keys(t).forEach(n => {
      let s = {
        type: "option",
        name: n,
        parent: e
      };
      if (r === "preset" && nn[n]) throw new Error(`${(0, c.msg)(s)} is not allowed in preset options`);
      if (r !== "arguments" && tn[n]) throw new Error(`${(0, c.msg)(s)} is only allowed in root programmatic options`);
      if (r !== "arguments" && r !== "configfile" && rn[n]) throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, c.msg)(s)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, c.msg)(s)} is only allowed in root programmatic options, or babel.config.js/config file options`);
      (sn[n] || nn[n] || rn[n] || tn[n] || mi)(s, t[n]);
    }), t;
  }

  o(wt, "validateNested");

  function mi(e) {
    let t = e.name;

    if (en.default[t]) {
      let {
        message: r,
        version: n = 5
      } = en.default[t];
      throw new Error(`Using removed Babel ${n} option: ${(0, c.msg)(e)} - ${r}`);
    } else {
      let r = new Error(`Unknown option: ${(0, c.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
      throw r.code = "BABEL_UNKNOWN_OPTION", r;
    }
  }

  o(mi, "throwUnknownError");

  function on(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }

  o(on, "has");

  function hi(e) {
    if (on(e, "sourceMap") && on(e, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }

  o(hi, "assertNoDuplicateSourcemap");

  function yi(e, t) {
    if (e.parent.type === "env") throw new Error(`${(0, c.msg)(e)} is not allowed inside of another .env block`);
    let r = e.parent,
        n = (0, c.assertObject)(e, t);
    if (n) for (let s of Object.keys(n)) {
      let i = (0, c.assertObject)((0, c.access)(e, s), n[s]);
      if (!i) continue;
      wt({
        type: "env",
        name: s,
        parent: r
      }, i);
    }
    return n;
  }

  o(yi, "assertEnvSet");

  function vi(e, t) {
    if (e.parent.type === "env") throw new Error(`${(0, c.msg)(e)} is not allowed inside an .env block`);
    if (e.parent.type === "overrides") throw new Error(`${(0, c.msg)(e)} is not allowed inside an .overrides block`);
    let r = e.parent,
        n = (0, c.assertArray)(e, t);
    if (n) for (let [s, i] of n.entries()) {
      let a = (0, c.access)(e, s),
          u = (0, c.assertObject)(a, i);
      if (!u) throw new Error(`${(0, c.msg)(a)} must be an object`);
      wt({
        type: "overrides",
        index: s,
        parent: r
      }, u);
    }
    return n;
  }

  o(vi, "assertOverridesList");

  function wi(e, t, r, n) {
    if (t === 0) return;
    let s = e[t - 1],
        i = e[t];
    s.file && s.options === void 0 && typeof i.value == "object" && (n.message += `
- Maybe you meant to use
"${r}s": [
  ["${s.file.request}", ${JSON.stringify(i.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
  }

  o(wi, "checkNoUnwrappedItemOptionPairs");
});
var cn = g(Et => {
  "use strict";

  Object.defineProperty(Et, "__esModule", {
    value: !0
  });
  Et.default = Pi;

  function Ue() {
    let e = __path$;
    return Ue = o(function () {
      return e;
    }, "_path"), e;
  }

  o(Ue, "_path");
  var de = `\\${Ue().sep}`,
      _t = `(?:${de}|$)`,
      Ot = `[^${de}]+`,
      Pt = `(?:${Ot}${de})`,
      ln = `(?:${Ot}${_t})`,
      _i = `${Pt}*?`,
      Oi = `${Pt}*?${ln}?`;

  function un(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }

  o(un, "escapeRegExp");

  function Pi(e, t) {
    let r = Ue().resolve(t, e).split(Ue().sep);
    return new RegExp(["^", ...r.map((n, s) => {
      let i = s === r.length - 1;
      return n === "**" ? i ? Oi : _i : n === "*" ? i ? ln : Pt : n.indexOf("*.") === 0 ? Ot + un(n.slice(1)) + (i ? _t : de) : un(n) + (i ? _t : de);
    })].join(""));
  }

  o(Pi, "pathToPattern");
});
var bn = g(Q => {
  "use strict";

  Object.defineProperty(Q, "__esModule", {
    value: !0
  });
  Q.ConfigPrinter = Q.ChainFormatter = void 0;

  function pn() {
    let e = __gensync$;
    return pn = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(pn, "_gensync");
  var dn = {
    Programmatic: 0,
    Config: 1
  };
  Q.ChainFormatter = dn;
  var Ct = {
    title(e, t, r) {
      let n = "";
      return e === dn.Programmatic ? (n = "programmatic options", t && (n += " from " + t)) : n = "config " + r, n;
    },

    loc(e, t) {
      let r = "";
      return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
    },

    *optionsAndDescriptors(e) {
      let t = Object.assign({}, e.options);
      delete t.overrides, delete t.env;
      let r = [...(yield* e.plugins())];
      r.length && (t.plugins = r.map(s => fn(s)));
      let n = [...(yield* e.presets())];
      return n.length && (t.presets = [...n].map(s => fn(s))), JSON.stringify(t, void 0, 2);
    }

  };

  function fn(e) {
    var t;
    let r = (t = e.file) == null ? void 0 : t.request;
    return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
  }

  o(fn, "descriptorToConfig");
  var X = class {
    constructor() {
      this._stack = [];
    }

    configure(t, r, {
      callerName: n,
      filepath: s
    }) {
      return t ? (i, a, u) => {
        this._stack.push({
          type: r,
          callerName: n,
          filepath: s,
          content: i,
          index: a,
          envName: u
        });
      } : () => {};
    }

    static *format(t) {
      let r = Ct.title(t.type, t.callerName, t.filepath),
          n = Ct.loc(t.index, t.envName);
      n && (r += ` ${n}`);
      let s = yield* Ct.optionsAndDescriptors(t.content);
      return `${r}
${s}`;
    }

    *output() {
      return this._stack.length === 0 ? "" : (yield* pn().all(this._stack.map(r => X.format(r)))).join(`

`);
    }

  };
  o(X, "ConfigPrinter");
  Q.ConfigPrinter = X;
});
var It = g(ee => {
  "use strict";

  Object.defineProperty(ee, "__esModule", {
    value: !0
  });
  ee.buildPresetChain = Ei;
  ee.buildPresetChainWalker = void 0;
  ee.buildRootChain = ji;

  function hn() {
    let e = __path$;
    return hn = o(function () {
      return e;
    }, "_path"), e;
  }

  o(hn, "_path");

  function yn() {
    let e = __debug$;
    return yn = o(function () {
      return e;
    }, "_debug"), e;
  }

  o(yn, "_debug");
  var jt = pe(),
      vn = cn(),
      ge = bn(),
      be = ne(),
      S = se(),
      M = gt(),
      gn = yn()("babel:config:config-chain");

  function* Ei(e, t) {
    let r = yield* wn(e, t);
    return r ? {
      plugins: Ve(r.plugins),
      presets: Ve(r.presets),
      options: r.options.map(n => _n(n)),
      files: new Set()
    } : null;
  }

  o(Ei, "buildPresetChain");
  var wn = Nt({
    root: e => Ci(e),
    env: (e, t) => Si(e)(t),
    overrides: (e, t) => Ai(e)(t),
    overridesEnv: (e, t, r) => ki(e)(t)(r),
    createLogger: () => () => {}
  });
  ee.buildPresetChainWalker = wn;
  var Ci = (0, S.makeWeakCacheSync)(e => xt(e, e.alias, M.createUncachedDescriptors)),
      Si = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => Ft(e, e.alias, M.createUncachedDescriptors, t))),
      Ai = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => Mt(e, e.alias, M.createUncachedDescriptors, t))),
      ki = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => (0, S.makeStrongCacheSync)(r => $t(e, e.alias, M.createUncachedDescriptors, t, r))));

  function* ji(e, t) {
    let r,
        n,
        s = new ge.ConfigPrinter(),
        i = yield* Ni({
      options: e,
      dirname: t.cwd
    }, t, void 0, s);
    if (!i) return null;
    let a = yield* s.output(),
        u;
    typeof e.configFile == "string" ? u = yield* (0, be.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (u = yield* (0, be.findRootConfig)(t.root, t.envName, t.caller));
    let {
      babelrc: l,
      babelrcRoots: f
    } = e,
        d = t.cwd,
        y = He(),
        w = new ge.ConfigPrinter();

    if (u) {
      let _ = Fi(u),
          G = yield* At(_, t, void 0, w);

      if (!G) return null;
      r = yield* w.output(), l === void 0 && (l = _.options.babelrc), f === void 0 && (d = _.dirname, f = _.options.babelrcRoots), Z(y, G);
    }

    let v,
        m,
        P = !1,
        E = He();

    if ((l === !0 || l === void 0) && typeof t.filename == "string") {
      let _ = yield* (0, be.findPackageData)(t.filename);

      if (_ && xi(t, _, f, d)) {
        if (({
          ignore: v,
          config: m
        } = yield* (0, be.findRelativeConfig)(_, t.envName, t.caller)), v && E.files.add(v.filepath), v && On(t, v.ignore, null, v.dirname) && (P = !0), m && !P) {
          let G = Mi(m),
              $ = new ge.ConfigPrinter(),
              F = yield* At(G, t, void 0, $);
          F ? (n = yield* $.output(), Z(E, F)) : P = !0;
        }

        m && P && E.files.add(m.filepath);
      }
    }

    t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, n, a].filter(_ => !!_).join(`

`) + `
-----End Babel configs-----`);
    let R = Z(Z(Z(He(), y), E), i);
    return {
      plugins: P ? [] : Ve(R.plugins),
      presets: P ? [] : Ve(R.presets),
      options: P ? [] : R.options.map(_ => _n(_)),
      fileHandling: P ? "ignored" : "transpile",
      ignore: v || void 0,
      babelrc: m || void 0,
      config: u || void 0,
      files: R.files
    };
  }

  o(ji, "buildRootChain");

  function xi(e, t, r, n) {
    if (typeof r == "boolean") return r;
    let s = e.root;
    if (r === void 0) return t.directories.indexOf(s) !== -1;
    let i = r;
    return Array.isArray(i) || (i = [i]), i = i.map(a => typeof a == "string" ? hn().resolve(n, a) : a), i.length === 1 && i[0] === s ? t.directories.indexOf(s) !== -1 : i.some(a => (typeof a == "string" && (a = (0, vn.default)(a, n)), t.directories.some(u => Pn(a, n, u, e))));
  }

  o(xi, "babelrcLoadEnabled");
  var Fi = (0, S.makeWeakCacheSync)(e => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, jt.validate)("configfile", e.options)
  })),
      Mi = (0, S.makeWeakCacheSync)(e => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, jt.validate)("babelrcfile", e.options)
  })),
      $i = (0, S.makeWeakCacheSync)(e => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, jt.validate)("extendsfile", e.options)
  })),
      Ni = Nt({
    root: e => xt(e, "base", M.createCachedDescriptors),
    env: (e, t) => Ft(e, "base", M.createCachedDescriptors, t),
    overrides: (e, t) => Mt(e, "base", M.createCachedDescriptors, t),
    overridesEnv: (e, t, r) => $t(e, "base", M.createCachedDescriptors, t, r),
    createLogger: (e, t, r) => Li(e, t, r)
  }),
      Ii = Nt({
    root: e => qi(e),
    env: (e, t) => Di(e)(t),
    overrides: (e, t) => Ri(e)(t),
    overridesEnv: (e, t, r) => Ti(e)(t)(r),
    createLogger: (e, t, r) => Bi(e.filepath, t, r)
  });

  function* At(e, t, r, n) {
    let s = yield* Ii(e, t, r, n);
    return s && s.files.add(e.filepath), s;
  }

  o(At, "loadFileChain");
  var qi = (0, S.makeWeakCacheSync)(e => xt(e, e.filepath, M.createUncachedDescriptors)),
      Di = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => Ft(e, e.filepath, M.createUncachedDescriptors, t))),
      Ri = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => Mt(e, e.filepath, M.createUncachedDescriptors, t))),
      Ti = (0, S.makeWeakCacheSync)(e => (0, S.makeStrongCacheSync)(t => (0, S.makeStrongCacheSync)(r => $t(e, e.filepath, M.createUncachedDescriptors, t, r))));

  function Bi(e, t, r) {
    return r ? r.configure(t.showConfig, ge.ChainFormatter.Config, {
      filepath: e
    }) : () => {};
  }

  o(Bi, "buildFileLogger");

  function xt({
    dirname: e,
    options: t
  }, r, n) {
    return n(e, t, r);
  }

  o(xt, "buildRootDescriptors");

  function Li(e, t, r) {
    var n;
    return r ? r.configure(t.showConfig, ge.ChainFormatter.Programmatic, {
      callerName: (n = t.caller) == null ? void 0 : n.name
    }) : () => {};
  }

  o(Li, "buildProgrammaticLogger");

  function Ft({
    dirname: e,
    options: t
  }, r, n, s) {
    let i = t.env && t.env[s];
    return i ? n(e, i, `${r}.env["${s}"]`) : null;
  }

  o(Ft, "buildEnvDescriptors");

  function Mt({
    dirname: e,
    options: t
  }, r, n, s) {
    let i = t.overrides && t.overrides[s];
    if (!i) throw new Error("Assertion failure - missing override");
    return n(e, i, `${r}.overrides[${s}]`);
  }

  o(Mt, "buildOverrideDescriptors");

  function $t({
    dirname: e,
    options: t
  }, r, n, s, i) {
    let a = t.overrides && t.overrides[s];
    if (!a) throw new Error("Assertion failure - missing override");
    let u = a.env && a.env[i];
    return u ? n(e, u, `${r}.overrides[${s}].env["${i}"]`) : null;
  }

  o($t, "buildOverrideEnvDescriptors");

  function Nt({
    root: e,
    env: t,
    overrides: r,
    overridesEnv: n,
    createLogger: s
  }) {
    return function* (i, a, u = new Set(), l) {
      let {
        dirname: f
      } = i,
          d = [],
          y = e(i);

      if (We(y, f, a)) {
        d.push({
          config: y,
          envName: void 0,
          index: void 0
        });
        let m = t(i, a.envName);
        m && We(m, f, a) && d.push({
          config: m,
          envName: a.envName,
          index: void 0
        }), (y.options.overrides || []).forEach((P, E) => {
          let R = r(i, E);

          if (We(R, f, a)) {
            d.push({
              config: R,
              index: E,
              envName: void 0
            });

            let _ = n(i, E, a.envName);

            _ && We(_, f, a) && d.push({
              config: _,
              index: E,
              envName: a.envName
            });
          }
        });
      }

      if (d.some(({
        config: {
          options: {
            ignore: m,
            only: P
          }
        }
      }) => On(a, m, P, f))) return null;
      let w = He(),
          v = s(i, a, l);

      for (let {
        config: m,
        index: P,
        envName: E
      } of d) {
        if (!(yield* Ui(w, m.options, f, a, u, l))) return null;
        v(m, P, E), yield* Wi(w, m);
      }

      return w;
    };
  }

  o(Nt, "makeChainWalker");

  function* Ui(e, t, r, n, s, i) {
    if (t.extends === void 0) return !0;
    let a = yield* (0, be.loadConfig)(t.extends, r, n.envName, n.caller);
    if (s.has(a)) throw new Error(`Configuration cycle detected loading ${a.filepath}.
File already loaded following the config chain:
` + Array.from(s, l => ` - ${l.filepath}`).join(`
`));
    s.add(a);
    let u = yield* At($i(a), n, s, i);
    return s.delete(a), u ? (Z(e, u), !0) : !1;
  }

  o(Ui, "mergeExtendsChain");

  function Z(e, t) {
    e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);

    for (let r of t.files) e.files.add(r);

    return e;
  }

  o(Z, "mergeChain");

  function* Wi(e, {
    options: t,
    plugins: r,
    presets: n
  }) {
    return e.options.push(t), e.plugins.push(...(yield* r())), e.presets.push(...(yield* n())), e;
  }

  o(Wi, "mergeChainOpts");

  function He() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: new Set()
    };
  }

  o(He, "emptyChain");

  function _n(e) {
    let t = Object.assign({}, e);
    return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.only, delete t.test, delete t.include, delete t.exclude, Object.prototype.hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap), t;
  }

  o(_n, "normalizeOptions");

  function Ve(e) {
    let t = new Map(),
        r = [];

    for (let n of e) if (typeof n.value == "function") {
      let s = n.value,
          i = t.get(s);
      i || (i = new Map(), t.set(s, i));
      let a = i.get(n.name);
      a ? a.value = n : (a = {
        value: n
      }, r.push(a), n.ownPass || i.set(n.name, a));
    } else r.push({
      value: n
    });

    return r.reduce((n, s) => (n.push(s.value), n), []);
  }

  o(Ve, "dedupDescriptors");

  function We({
    options: e
  }, t, r) {
    return (e.test === void 0 || St(r, e.test, t)) && (e.include === void 0 || St(r, e.include, t)) && (e.exclude === void 0 || !St(r, e.exclude, t));
  }

  o(We, "configIsApplicable");

  function St(e, t, r) {
    let n = Array.isArray(t) ? t : [t];
    return kt(e, n, r);
  }

  o(St, "configFieldIsApplicable");

  function mn(e, t) {
    return t instanceof RegExp ? String(t) : t;
  }

  o(mn, "ignoreListReplacer");

  function On(e, t, r, n) {
    if (t && kt(e, t, n)) {
      var s;
      let a = `No config is applied to "${(s = e.filename) != null ? s : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t, mn)}\` from "${n}"`;
      return gn(a), e.showConfig && console.log(a), !0;
    }

    if (r && !kt(e, r, n)) {
      var i;
      let a = `No config is applied to "${(i = e.filename) != null ? i : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r, mn)}\` from "${n}"`;
      return gn(a), e.showConfig && console.log(a), !0;
    }

    return !1;
  }

  o(On, "shouldIgnore");

  function kt(e, t, r) {
    return t.some(n => Pn(n, r, e.filename, e));
  }

  o(kt, "matchesPatterns");

  function Pn(e, t, r, n) {
    if (typeof e == "function") return !!e(r, {
      dirname: t,
      envName: n.envName,
      caller: n.caller
    });
    if (typeof r != "string") throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
    return typeof e == "string" && (e = (0, vn.default)(e, t)), e.test(r);
  }

  o(Pn, "matchPattern");
});
var En = g(qt => {
  "use strict";

  Object.defineProperty(qt, "__esModule", {
    value: !0
  });
  qt.validatePluginObject = zi;
  var D = vt(),
      Hi = {
    name: D.assertString,
    manipulateOptions: D.assertFunction,
    pre: D.assertFunction,
    post: D.assertFunction,
    inherits: D.assertFunction,
    visitor: Vi,
    parserOverride: D.assertFunction,
    generatorOverride: D.assertFunction
  };

  function Vi(e, t) {
    let r = (0, D.assertObject)(e, t);
    if (r && (Object.keys(r).forEach(n => Gi(n, r[n])), r.enter || r.exit)) throw new Error(`${(0, D.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r;
  }

  o(Vi, "assertVisitorMap");

  function Gi(e, t) {
    if (t && typeof t == "object") Object.keys(t).forEach(r => {
      if (r !== "enter" && r !== "exit") throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
    });else if (typeof t != "function") throw new Error(`.visitor["${e}"] must be a function`);
    return t;
  }

  o(Gi, "assertVisitorHandler");

  function zi(e) {
    let t = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(e).forEach(r => {
      let n = Hi[r];
      if (n) n({
        type: "option",
        name: r,
        parent: t
      }, e[r]);else {
        let s = new Error(`.${r} is not a valid Plugin property`);
        throw s.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", s;
      }
    }), e;
  }

  o(zi, "validatePluginObject");
});
var Dt = g(() => {});
var jn = g(me => {
  "use strict";

  Object.defineProperty(me, "__esModule", {
    value: !0
  });
  me.makeConfigAPI = An;
  me.makePluginAPI = Ji;
  me.makePresetAPI = kn;

  function Sn() {
    let e = __semver$;
    return Sn = o(function () {
      return e;
    }, "_semver"), e;
  }

  o(Sn, "_semver");
  var Ge = he(),
      Cn = se(),
      Zu = Dt();

  function An(e) {
    let t = o(n => e.using(s => typeof n > "u" ? s.envName : typeof n == "function" ? (0, Cn.assertSimpleType)(n(s.envName)) : (Array.isArray(n) || (n = [n]), n.some(i => {
      if (typeof i != "string") throw new Error("Unexpected non-string value");
      return i === s.envName;
    }))), "env"),
        r = o(n => e.using(s => (0, Cn.assertSimpleType)(n(s.caller))), "caller");
    return {
      version: Ge.version,
      cache: e.simple(),
      env: t,
      async: () => !1,
      caller: r,
      assertVersion: Yi
    };
  }

  o(An, "makeConfigAPI");

  function kn(e, t) {
    let r = o(() => JSON.parse(e.using(s => JSON.stringify(s.targets))), "targets"),
        n = o(s => {
      t.push(s);
    }, "addExternalDependency");
    return Object.assign({}, An(e), {
      targets: r,
      addExternalDependency: n
    });
  }

  o(kn, "makePresetAPI");

  function Ji(e, t) {
    let r = o(n => e.using(s => s.assumptions[n]), "assumption");
    return Object.assign({}, kn(e, t), {
      assumption: r
    });
  }

  o(Ji, "makePluginAPI");

  function Yi(e) {
    if (typeof e == "number") {
      if (!Number.isInteger(e)) throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }

    if (typeof e != "string") throw new Error("Expected string or integer value.");
    if (Sn().satisfies(Ge.version, e)) return;
    let t = Error.stackTraceLimit;
    typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
    let r = new Error(`Requires Babel "${e}", but was loaded with "${Ge.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: Ge.version,
      range: e
    });
  }

  o(Yi, "assertVersion");
});
var Rt = g(ve => {
  "use strict";

  Object.defineProperty(ve, "__esModule", {
    value: !0
  });
  ve.default = Mn;
  ve.loadPartialConfig = void 0;

  function ze() {
    let e = __path$;
    return ze = o(function () {
      return e;
    }, "_path"), e;
  }

  o(ze, "_path");

  function Fn() {
    let e = __gensync$;
    return Fn = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(Fn, "_gensync");
  var Ki = oe(),
      Xi = Fe(),
      xn = ue(),
      Qi = It(),
      Zi = pt(),
      ea = pe(),
      Je = ne(),
      ta = bt(),
      ra = ["showIgnoredFiles"];

  function na(e, t) {
    if (e == null) return {};
    var r = {},
        n = Object.keys(e),
        s,
        i;

    for (i = 0; i < n.length; i++) s = n[i], !(t.indexOf(s) >= 0) && (r[s] = e[s]);

    return r;
  }

  o(na, "_objectWithoutPropertiesLoose");

  function oa(e, t) {
    switch (t) {
      case "root":
        return e;

      case "upward-optional":
        {
          let r = (0, Je.findConfigUpwards)(e);
          return r === null ? e : r;
        }

      case "upward":
        {
          let r = (0, Je.findConfigUpwards)(e);
          if (r !== null) return r;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".
One of the following config files must be in the directory tree: "${Je.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: e
          });
        }

      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }

  o(oa, "resolveRootMode");

  function* Mn(e) {
    if (e != null && (typeof e != "object" || Array.isArray(e))) throw new Error("Babel options must be an object, null, or undefined");
    let t = e ? (0, ea.validate)("arguments", e) : {},
        {
      envName: r = (0, Zi.getEnv)(),
      cwd: n = ".",
      root: s = ".",
      rootMode: i = "root",
      caller: a,
      cloneInputAst: u = !0
    } = t,
        l = ze().resolve(n),
        f = oa(ze().resolve(l, s), i),
        d = typeof t.filename == "string" ? ze().resolve(n, t.filename) : void 0,
        y = yield* (0, Je.resolveShowConfigPath)(l),
        w = {
      filename: d,
      cwd: l,
      root: f,
      envName: r,
      caller: a,
      showConfig: y === d
    },
        v = yield* (0, Qi.buildRootChain)(t, w);
    if (!v) return null;
    let m = {
      assumptions: {}
    };
    return v.options.forEach(E => {
      (0, Xi.mergeOptions)(m, E);
    }), {
      options: Object.assign({}, m, {
        targets: (0, ta.resolveTargets)(m, f),
        cloneInputAst: u,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: w.envName,
        cwd: w.cwd,
        root: w.root,
        rootMode: "root",
        filename: typeof w.filename == "string" ? w.filename : void 0,
        plugins: v.plugins.map(E => (0, xn.createItemFromDescriptor)(E)),
        presets: v.presets.map(E => (0, xn.createItemFromDescriptor)(E))
      }),
      context: w,
      fileHandling: v.fileHandling,
      ignore: v.ignore,
      babelrc: v.babelrc,
      config: v.config,
      files: v.files
    };
  }

  o(Mn, "loadPrivatePartialConfig");
  var sa = Fn()(function* (e) {
    let t = !1;

    if (typeof e == "object" && e !== null && !Array.isArray(e)) {
      var r = e;
      ({
        showIgnoredFiles: t
      } = r), e = na(r, ra);
    }

    let n = yield* Mn(e);
    if (!n) return null;
    let {
      options: s,
      babelrc: i,
      ignore: a,
      config: u,
      fileHandling: l,
      files: f
    } = n;
    return l === "ignored" && !t ? null : ((s.plugins || []).forEach(d => {
      if (d.value instanceof Ki.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new ye(s, i ? i.filepath : void 0, a ? a.filepath : void 0, u ? u.filepath : void 0, l, f));
  });
  ve.loadPartialConfig = sa;
  var ye = class {
    constructor(t, r, n, s, i, a) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = t, this.babelignore = n, this.babelrc = r, this.config = s, this.fileHandling = i, this.files = a, Object.freeze(this);
    }

    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }

  };
  o(ye, "PartialConfig");
  Object.freeze(ye.prototype);
});
var Ln = g(Ye => {
  "use strict";

  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.default = void 0;

  function qn() {
    let e = __gensync$;
    return qn = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(qn, "_gensync");
  var Bt = dt(),
      $n = Fe(),
      ia = he(),
      Dn = oe(),
      aa = ue(),
      ua = It(),
      Wt = $e();

  function Lt() {
    let e = ___babel_traverse$;
    return Lt = o(function () {
      return e;
    }, "_traverse"), e;
  }

  o(Lt, "_traverse");
  var Ht = se(),
      Ut = pe(),
      la = En(),
      Rn = jn(),
      ca = Rt(),
      rl = Dt(),
      fa = qn()(o(function* (t) {
    var r;
    let n = yield* (0, ca.default)(t);
    if (!n) return null;
    let {
      options: s,
      context: i,
      fileHandling: a
    } = n;
    if (a === "ignored") return null;
    let u = {},
        {
      plugins: l,
      presets: f
    } = s;
    if (!l || !f) throw new Error("Assertion failure - plugins and presets exist");
    let d = Object.assign({}, i, {
      targets: s.targets
    }),
        y = o($ => {
      let F = (0, aa.getItemDescriptor)($);
      if (!F) throw new Error("Assertion failure - must be config item");
      return F;
    }, "toDescriptor"),
        w = f.map(y),
        v = l.map(y),
        m = [[]],
        P = [],
        E = [];
    if (yield* Nn(i, o(function* $(F, z) {
      let T = [];

      for (let A = 0; A < F.length; A++) {
        let I = F[A];

        if (I.options !== !1) {
          try {
            var B = yield* ma(I, d);
          } catch (Pe) {
            throw Pe.code === "BABEL_UNKNOWN_OPTION" && (0, Ut.checkNoUnwrappedItemOptionPairs)(F, A, "preset", Pe), Pe;
          }

          E.push(B.externalDependencies), I.ownPass ? T.push({
            preset: B.chain,
            pass: []
          }) : T.unshift({
            preset: B.chain,
            pass: z
          });
        }
      }

      if (T.length > 0) {
        m.splice(1, 0, ...T.map(A => A.pass).filter(A => A !== z));

        for (let {
          preset: A,
          pass: I
        } of T) {
          if (!A || (I.push(...A.plugins), yield* $(A.presets, I))) return !0;
          A.options.forEach(Ao => {
            (0, $n.mergeOptions)(u, Ao);
          });
        }
      }
    }, "recursePresetDescriptors"))(w, m[0])) return null;
    let _ = u;
    (0, $n.mergeOptions)(_, s);
    let G = Object.assign({}, d, {
      assumptions: (r = _.assumptions) != null ? r : {}
    });
    return yield* Nn(i, o(function* () {
      m[0].unshift(...v);

      for (let z of m) {
        let T = [];
        P.push(T);

        for (let B = 0; B < z.length; B++) {
          let A = z[B];

          if (A.options !== !1) {
            try {
              var F = yield* Bn(A, G);
            } catch (I) {
              throw I.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, Ut.checkNoUnwrappedItemOptionPairs)(z, B, "plugin", I), I;
            }

            T.push(F), E.push(F.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), _.plugins = P[0], _.presets = P.slice(1).filter($ => $.length > 0).map($ => ({
      plugins: $
    })), _.passPerPreset = _.presets.length > 0, {
      options: _,
      passes: P,
      externalDependencies: (0, Wt.finalize)(E)
    };
  }, "loadFullConfig"));
  Ye.default = fa;

  function Nn(e, t) {
    return function* (r, n) {
      try {
        return yield* t(r, n);
      } catch (s) {
        throw /^\[BABEL\]/.test(s.message) || (s.message = `[BABEL] ${e.filename || "unknown"}: ${s.message}`), s;
      }
    };
  }

  o(Nn, "enhanceError");
  var Tn = o(e => (0, Ht.makeWeakCache)(function* ({
    value: t,
    options: r,
    dirname: n,
    alias: s
  }, i) {
    if (r === !1) throw new Error("Assertion failure");
    r = r || {};
    let a = [],
        u = t;

    if (typeof t == "function") {
      let l = (0, Bt.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"),
          f = Object.assign({}, ia, e(i, a));

      try {
        u = yield* l(f, r, n);
      } catch (d) {
        throw s && (d.message += ` (While processing: ${JSON.stringify(s)})`), d;
      }
    }

    if (!u || typeof u != "object") throw new Error("Plugin/Preset did not return an object.");
    if ((0, Bt.isThenable)(u)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(s)})`);

    if (a.length > 0 && (!i.configured() || i.mode() === "forever")) {
      let l = `A plugin/preset has external untracked dependencies (${a[0]}), but the cache `;
      throw i.configured() ? l += " has been configured to never be invalidated. " : l += "has not been configured to be invalidated when the external dependencies change. ", l += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(s)})`, new Error(l);
    }

    return {
      value: u,
      options: r,
      dirname: n,
      alias: s,
      externalDependencies: (0, Wt.finalize)(a)
    };
  }), "makeDescriptorLoader"),
      pa = Tn(Rn.makePluginAPI),
      da = Tn(Rn.makePresetAPI);

  function* Bn(e, t) {
    if (e.value instanceof Dn.default) {
      if (e.options) throw new Error("Passed options to an existing Plugin instance will not work.");
      return e.value;
    }

    return yield* ba(yield* pa(e, t), t);
  }

  o(Bn, "loadPluginDescriptor");
  var ba = (0, Ht.makeWeakCache)(function* ({
    value: e,
    options: t,
    dirname: r,
    alias: n,
    externalDependencies: s
  }, i) {
    let a = (0, la.validatePluginObject)(e),
        u = Object.assign({}, a);

    if (u.visitor && (u.visitor = Lt().default.explode(Object.assign({}, u.visitor))), u.inherits) {
      let l = {
        name: void 0,
        alias: `${n}$inherits`,
        value: u.inherits,
        options: t,
        dirname: r
      },
          f = yield* (0, Bt.forwardAsync)(Bn, d => i.invalidate(y => d(l, y)));
      u.pre = Tt(f.pre, u.pre), u.post = Tt(f.post, u.post), u.manipulateOptions = Tt(f.manipulateOptions, u.manipulateOptions), u.visitor = Lt().default.visitors.merge([f.visitor || {}, u.visitor || {}]), f.externalDependencies.length > 0 && (s.length === 0 ? s = f.externalDependencies : s = (0, Wt.finalize)([s, f.externalDependencies]));
    }

    return new Dn.default(u, t, n, s);
  }),
      In = o((e, t) => {
    if (e.test || e.include || e.exclude) {
      let r = t.name ? `"${t.name}"` : "/* your preset */";
      throw new Error([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transform(code, { filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"),
      ga = o((e, t, r) => {
    if (!t.filename) {
      let {
        options: n
      } = e;
      In(n, r), n.overrides && n.overrides.forEach(s => In(s, r));
    }
  }, "validatePreset");

  function* ma(e, t) {
    let r = ha(yield* da(e, t));
    return ga(r, t, e), {
      chain: yield* (0, ua.buildPresetChain)(r, t),
      externalDependencies: r.externalDependencies
    };
  }

  o(ma, "loadPresetDescriptor");
  var ha = (0, Ht.makeWeakCacheSync)(({
    value: e,
    dirname: t,
    alias: r,
    externalDependencies: n
  }) => ({
    options: (0, Ut.validate)("preset", e),
    alias: r,
    dirname: t,
    externalDependencies: n
  }));

  function Tt(e, t) {
    let r = [e, t].filter(Boolean);
    return r.length <= 1 ? r[0] : function (...n) {
      for (let s of r) s.apply(this, n);
    };
  }

  o(Tt, "chain");
});

var _e = g(C => {
  "use strict";

  Object.defineProperty(C, "__esModule", {
    value: !0
  });
  C.createConfigItem = Aa;
  C.createConfigItemSync = C.createConfigItemAsync = void 0;
  Object.defineProperty(C, "default", {
    enumerable: !0,
    get: function () {
      return Un.default;
    }
  });
  C.loadPartialConfigSync = C.loadPartialConfigAsync = C.loadPartialConfig = C.loadOptionsSync = C.loadOptionsAsync = C.loadOptions = void 0;

  function Vt() {
    let e = __gensync$;
    return Vt = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(Vt, "_gensync");
  var Un = Ln(),
      Gt = Rt(),
      ya = ue(),
      zt = Vt()(function* (e) {
    var t;
    let r = yield* (0, Un.default)(e);
    return (t = r?.options) != null ? t : null;
  }),
      we = Vt()(ya.createConfigItem),
      Wn = o(e => (t, r) => (r === void 0 && typeof t == "function" && (r = t, t = void 0), r ? e.errback(t, r) : e.sync(t)), "maybeErrback"),
      va = Wn(Gt.loadPartialConfig);
  C.loadPartialConfig = va;
  var wa = Gt.loadPartialConfig.sync;
  C.loadPartialConfigSync = wa;
  var _a = Gt.loadPartialConfig.async;
  C.loadPartialConfigAsync = _a;
  var Oa = Wn(zt);
  C.loadOptions = Oa;
  var Pa = zt.sync;
  C.loadOptionsSync = Pa;
  var Ea = zt.async;
  C.loadOptionsAsync = Ea;
  var Ca = we.sync;
  C.createConfigItemSync = Ca;
  var Sa = we.async;
  C.createConfigItemAsync = Sa;

  function Aa(e, t, r) {
    return r !== void 0 ? we.errback(e, t, r) : typeof t == "function" ? we.errback(e, void 0, r) : we.sync(e, t);
  }

  o(Aa, "createConfigItem");
});

var Hn = g(Ke => {
  "use strict";

  Object.defineProperty(Ke, "__esModule", {
    value: !0
  });
  Ke.default = void 0;
  var Oe = class {
    constructor(t, r, n) {
      this._map = new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = r, this.file = t, this.opts = n || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename;
    }

    set(t, r) {
      this._map.set(t, r);
    }

    get(t) {
      return this._map.get(t);
    }

    availableHelper(t, r) {
      return this.file.availableHelper(t, r);
    }

    addHelper(t) {
      return this.file.addHelper(t);
    }

    addImport() {
      return this.file.addImport();
    }

    buildCodeFrameError(t, r, n) {
      return this.file.buildCodeFrameError(t, r, n);
    }

  };
  o(Oe, "PluginPass");
  Ke.default = Oe;
  Oe.prototype.getModuleName = o(function () {
    return this.file.getModuleName();
  }, "getModuleName");
});
var Jn = g(Yt => {
  "use strict";

  Object.defineProperty(Yt, "__esModule", {
    value: !0
  });
  Yt.default = ja;

  function Gn() {
    let e = ___babel_traverse$;
    return Gn = o(function () {
      return e;
    }, "_traverse"), e;
  }

  o(Gn, "_traverse");
  var ka = oe(),
      Jt;

  function ja() {
    return Jt || (Jt = new ka.default(Object.assign({}, Vn, {
      visitor: Gn().default.explode(Vn.visitor)
    }), {})), Jt;
  }

  o(ja, "loadBlockHoistPlugin");

  function zn(e) {
    let t = e?._blockHoist;
    return t == null ? 1 : t === !0 ? 2 : t;
  }

  o(zn, "priority");

  function xa(e) {
    let t = Object.create(null);

    for (let s = 0; s < e.length; s++) {
      let i = e[s],
          a = zn(i);
      (t[a] || (t[a] = [])).push(i);
    }

    let r = Object.keys(t).map(s => +s).sort((s, i) => i - s),
        n = 0;

    for (let s of r) {
      let i = t[s];

      for (let a of i) e[n++] = a;
    }

    return e;
  }

  o(xa, "stableSort");
  var Vn = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: e
        }) {
          let {
            body: t
          } = e,
              r = Math.pow(2, 30) - 1,
              n = !1;

          for (let s = 0; s < t.length; s++) {
            let i = t[s],
                a = zn(i);

            if (a > r) {
              n = !0;
              break;
            }

            r = a;
          }

          !n || (e.body = xa(t.slice()));
        }

      }
    }
  };
});
var Xt = g(Kt => {
  "use strict";

  Object.defineProperty(Kt, "__esModule", {
    value: !0
  });
  Kt.default = Fa;

  function Xe() {
    let e = __path$;
    return Xe = o(function () {
      return e;
    }, "_path"), e;
  }

  o(Xe, "_path");

  function Fa(e) {
    let {
      filename: t,
      cwd: r,
      filenameRelative: n = typeof t == "string" ? Xe().relative(r, t) : "unknown",
      sourceType: s = "module",
      inputSourceMap: i,
      sourceMaps: a = !!i,
      sourceRoot: u = e.options.moduleRoot,
      sourceFileName: l = Xe().basename(n),
      comments: f = !0,
      compact: d = "auto"
    } = e.options,
        y = e.options,
        w = Object.assign({}, y, {
      parserOpts: Object.assign({
        sourceType: Xe().extname(n) === ".mjs" ? "module" : s,
        sourceFileName: t,
        plugins: []
      }, y.parserOpts),
      generatorOpts: Object.assign({
        filename: t,
        auxiliaryCommentBefore: y.auxiliaryCommentBefore,
        auxiliaryCommentAfter: y.auxiliaryCommentAfter,
        retainLines: y.retainLines,
        comments: f,
        shouldPrintComment: y.shouldPrintComment,
        compact: d,
        minified: y.minified,
        sourceMaps: a,
        sourceRoot: u,
        sourceFileName: l
      }, y.generatorOpts)
    });

    for (let v of e.passes) for (let m of v) m.manipulateOptions && m.manipulateOptions(w, w.parserOpts);

    return w;
  }

  o(Fa, "normalizeOptions");
});
var Kn = g(Zt => {
  "use strict";

  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Zt.default = Ma;
  var Qt = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-proposal-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-proposal-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-proposal-class-static-block"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-namespace-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-proposal-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-numeric-separator"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-optional-chaining"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-proposal-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-private-property-in-object"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-proposal-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    },
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-proposal-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-async-generator-functions"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-proposal-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-logical-assignment-operators"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-proposal-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-optional-catch-binding"
      }
    }
  };
  Qt.privateIn.syntax = Qt.privateIn.transform;
  var Yn = o(({
    name: e,
    url: t
  }) => `${e} (${t})`, "getNameURLCombination");

  function Ma(e, t, r) {
    let n = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r,
        s = Qt[e];

    if (s) {
      let {
        syntax: i,
        transform: a
      } = s;

      if (i) {
        let u = Yn(i);

        if (a) {
          let l = Yn(a),
              f = a.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          n += `

Add ${l} to the '${f}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${u} to the 'plugins' section to enable parsing.`;
        } else n += `

Add ${u} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }

    return n;
  }

  o(Ma, "generateMissingPluginMessage");
});
var rr = g(tr => {
  "use strict";

  Object.defineProperty(tr, "__esModule", {
    value: !0
  });
  tr.default = Na;

  function er() {
    let e = ___babel_parser$;
    return er = o(function () {
      return e;
    }, "_parser"), e;
  }

  o(er, "_parser");

  function Xn() {
    let e = ___babel_code_frame$;
    return Xn = o(function () {
      return e;
    }, "_codeFrame"), e;
  }

  o(Xn, "_codeFrame");
  var $a = Kn();

  function* Na(e, {
    parserOpts: t,
    highlightCode: r = !0,
    filename: n = "unknown"
  }, s) {
    try {
      let i = [];

      for (let a of e) for (let u of a) {
        let {
          parserOverride: l
        } = u;

        if (l) {
          let f = l(s, t, er().parse);
          f !== void 0 && i.push(f);
        }
      }

      if (i.length === 0) return (0, er().parse)(s, t);

      if (i.length === 1) {
        if (yield* [], typeof i[0].then == "function") throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
        return i[0];
      }

      throw new Error("More than one plugin attempted to override parsing.");
    } catch (i) {
      i.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (i.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: a,
        missingPlugin: u
      } = i;

      if (a) {
        let l = (0, Xn().codeFrameColumns)(s, {
          start: {
            line: a.line,
            column: a.column + 1
          }
        }, {
          highlightCode: r
        });
        u ? i.message = `${n}: ` + (0, $a.default)(u[0], a, l) : i.message = `${n}: ${i.message}

` + l, i.code = "BABEL_PARSE_ERROR";
      }

      throw i;
    }
  }

  o(Na, "parser");
});
var Zn = g(nr => {
  "use strict";

  Object.defineProperty(nr, "__esModule", {
    value: !0
  });
  nr.default = Da;
  var Qn = "$$ babel internal serialized type" + Math.random();

  function Ia(e, t) {
    return typeof t != "bigint" ? t : {
      [Qn]: "BigInt",
      value: t.toString()
    };
  }

  o(Ia, "serialize");

  function qa(e, t) {
    return !t || typeof t != "object" || t[Qn] !== "BigInt" ? t : BigInt(t.value);
  }

  o(qa, "revive");

  function Da(e) {
    return JSON.parse(JSON.stringify(e, Ia), qa);
  }

  o(Da, "_default");
});
var so = g(ir => {
  "use strict";

  Object.defineProperty(ir, "__esModule", {
    value: !0
  });
  ir.default = Ha;

  function ro() {
    let e = __fs$;
    return ro = o(function () {
      return e;
    }, "_fs"), e;
  }

  o(ro, "_fs");

  function sr() {
    let e = __path$;
    return sr = o(function () {
      return e;
    }, "_path"), e;
  }

  o(sr, "_path");

  function no() {
    let e = __debug$;
    return no = o(function () {
      return e;
    }, "_debug"), e;
  }

  o(no, "_debug");

  function oo() {
    let e = ___babel_types$;
    return oo = o(function () {
      return e;
    }, "_t"), e;
  }

  o(oo, "_t");

  function Ze() {
    let e = __convert_source_map$;
    return Ze = o(function () {
      return e;
    }, "_convertSourceMap"), e;
  }

  o(Ze, "_convertSourceMap");
  var Ra = Se(),
      Ta = rr(),
      Ba = Zn(),
      {
    file: La,
    traverseFast: Ua
  } = oo(),
      Qe = no()("babel:transform:file"),
      Wa = 1e6;

  function* Ha(e, t, r, n) {
    if (r = `${r || ""}`, n) {
      if (n.type === "Program") n = La(n, [], []);else if (n.type !== "File") throw new Error("AST root must be a Program or File node");
      t.cloneInputAst && (n = (0, Ba.default)(n));
    } else n = yield* (0, Ta.default)(e, t, r);

    let s = null;

    if (t.inputSourceMap !== !1) {
      if (typeof t.inputSourceMap == "object" && (s = Ze().fromObject(t.inputSourceMap)), !s) {
        let i = to(Va, n);
        if (i) try {
          s = Ze().fromComment(i);
        } catch (a) {
          Qe("discarding unknown inline input sourcemap", a);
        }
      }

      if (!s) {
        let i = to(eo, n);
        if (typeof t.filename == "string" && i) try {
          let a = eo.exec(i),
              u = ro().readFileSync(sr().resolve(sr().dirname(t.filename), a[1]));
          u.length > Wa ? Qe("skip merging input map > 1 MB") : s = Ze().fromJSON(u);
        } catch (a) {
          Qe("discarding unknown file input sourcemap", a);
        } else i && Qe("discarding un-loadable file input sourcemap");
      }
    }

    return new Ra.default(t, {
      code: r,
      ast: n,
      inputMap: s
    });
  }

  o(Ha, "normalizeFile");
  var Va = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/,
      eo = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

  function or(e, t, r) {
    return t && (t = t.filter(({
      value: n
    }) => e.test(n) ? (r = n, !1) : !0)), [t, r];
  }

  o(or, "extractCommentsFromList");

  function to(e, t) {
    let r = null;
    return Ua(t, n => {
      [n.leadingComments, r] = or(e, n.leadingComments, r), [n.innerComments, r] = or(e, n.innerComments, r), [n.trailingComments, r] = or(e, n.trailingComments, r);
    }), r;
  }

  o(to, "extractComments");
});
var uo = g(ar => {
  "use strict";

  Object.defineProperty(ar, "__esModule", {
    value: !0
  });
  ar.default = Ga;

  function ao() {
    let e = ___ampproject_remapping$;
    return ao = o(function () {
      return e;
    }, "_remapping"), e;
  }

  o(ao, "_remapping");

  function Ga(e, t, r) {
    let n = r.replace(/\\/g, "/"),
        s = !1,
        i = ao()(io(t), (a, u) => a === n && !s ? (s = !0, u.source = "", io(e)) : null);
    return typeof e.sourceRoot == "string" && (i.sourceRoot = e.sourceRoot), Object.assign({}, i);
  }

  o(Ga, "mergeSourceMap");

  function io(e) {
    return Object.assign({}, e, {
      sourceRoot: null
    });
  }

  o(io, "rootless");
});
var co = g(lr => {
  "use strict";

  Object.defineProperty(lr, "__esModule", {
    value: !0
  });
  lr.default = Ja;

  function lo() {
    let e = __convert_source_map$;
    return lo = o(function () {
      return e;
    }, "_convertSourceMap"), e;
  }

  o(lo, "_convertSourceMap");

  function ur() {
    let e = ___babel_generator$;
    return ur = o(function () {
      return e;
    }, "_generator"), e;
  }

  o(ur, "_generator");
  var za = uo();

  function Ja(e, t) {
    let {
      opts: r,
      ast: n,
      code: s,
      inputMap: i
    } = t,
        {
      generatorOpts: a
    } = r,
        u = [];

    for (let y of e) for (let w of y) {
      let {
        generatorOverride: v
      } = w;

      if (v) {
        let m = v(n, a, s, ur().default);
        m !== void 0 && u.push(m);
      }
    }

    let l;
    if (u.length === 0) l = (0, ur().default)(n, a, s);else if (u.length === 1) {
      if (l = u[0], typeof l.then == "function") throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
    } else throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: f,
      decodedMap: d = l.map
    } = l;
    return d && (i ? d = (0, za.default)(i.toObject(), d, a.sourceFileName) : d = l.map), (r.sourceMaps === "inline" || r.sourceMaps === "both") && (f += `
` + lo().fromObject(d).toComment()), r.sourceMaps === "inline" && (d = null), {
      outputCode: f,
      outputMap: d
    };
  }

  o(Ja, "generateCode");
});
var pr = g(fr => {
  "use strict";

  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr.run = tu;

  function cr() {
    let e = ___babel_traverse$;
    return cr = o(function () {
      return e;
    }, "_traverse"), e;
  }

  o(cr, "_traverse");
  var Ya = Hn(),
      Ka = Jn(),
      Xa = Xt(),
      Qa = so(),
      Za = co(),
      eu = $e();

  function* tu(e, t, r) {
    let n = yield* (0, Qa.default)(e.passes, (0, Xa.default)(e), t, r),
        s = n.opts;

    try {
      yield* ru(n, e.passes);
    } catch (f) {
      var i;
      throw f.message = `${(i = s.filename) != null ? i : "unknown"}: ${f.message}`, f.code || (f.code = "BABEL_TRANSFORM_ERROR"), f;
    }

    let a, u;

    try {
      s.code !== !1 && ({
        outputCode: a,
        outputMap: u
      } = (0, Za.default)(e.passes, n));
    } catch (f) {
      var l;
      throw f.message = `${(l = s.filename) != null ? l : "unknown"}: ${f.message}`, f.code || (f.code = "BABEL_GENERATE_ERROR"), f;
    }

    return {
      metadata: n.metadata,
      options: s,
      ast: s.ast === !0 ? n.ast : null,
      code: a === void 0 ? null : a,
      map: u === void 0 ? null : u,
      sourceType: n.ast.program.sourceType,
      externalDependencies: (0, eu.flattenToSet)(e.externalDependencies)
    };
  }

  o(tu, "run");

  function* ru(e, t) {
    for (let r of t) {
      let n = [],
          s = [],
          i = [];

      for (let u of r.concat([(0, Ka.default)()])) {
        let l = new Ya.default(e, u.key, u.options);
        n.push([u, l]), s.push(l), i.push(u.visitor);
      }

      for (let [u, l] of n) {
        let f = u.pre;

        if (f) {
          let d = f.call(l, e);
          if (yield* [], fo(d)) throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }

      let a = cr().default.visitors.merge(i, s, e.opts.wrapPluginVisitorMethod);
      (0, cr().default)(e.ast, a, e.scope);

      for (let [u, l] of n) {
        let f = u.post;

        if (f) {
          let d = f.call(l, e);
          if (yield* [], fo(d)) throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }
    }
  }

  o(ru, "transformFile");

  function fo(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }

  o(fo, "isThenable");
});
var bo = g(U => {
  "use strict";

  Object.defineProperty(U, "__esModule", {
    value: !0
  });
  U.transformSync = U.transformAsync = U.transform = void 0;

  function po() {
    let e = __gensync$;
    return po = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(po, "_gensync");

  var nu = _e(),
      ou = pr(),
      et = po()(o(function* (t, r) {
    let n = yield* (0, nu.default)(r);
    return n === null ? null : yield* (0, ou.run)(n, t);
  }, "transform")),
      su = o(function (t, r, n) {
    if (typeof r == "function" && (n = r, r = void 0), n === void 0) return et.sync(t, r);
    et.errback(t, r, n);
  }, "transform");

  U.transform = su;
  var iu = et.sync;
  U.transformSync = iu;
  var au = et.async;
  U.transformAsync = au;
});
var go = g(te => {
  "use strict";

  Object.defineProperty(te, "__esModule", {
    value: !0
  });
  te.transformFile = void 0;
  te.transformFileAsync = cu;
  te.transformFileSync = lu;
  var uu = o(function (t, r, n) {
    typeof r == "function" && (n = r), n(new Error("Transforming files is not supported in browsers"), null);
  }, "transformFile");
  te.transformFile = uu;

  function lu() {
    throw new Error("Transforming files is not supported in browsers");
  }

  o(lu, "transformFileSync");

  function cu() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }

  o(cu, "transformFileAsync");
});
var ho = g(W => {
  "use strict";

  Object.defineProperty(W, "__esModule", {
    value: !0
  });
  W.transformFromAstSync = W.transformFromAstAsync = W.transformFromAst = void 0;

  function mo() {
    let e = __gensync$;
    return mo = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(mo, "_gensync");

  var fu = _e(),
      pu = pr(),
      tt = mo()(function* (e, t, r) {
    let n = yield* (0, fu.default)(r);
    if (n === null) return null;
    if (!e) throw new Error("No AST given");
    return yield* (0, pu.run)(n, t, e);
  }),
      du = o(function (t, r, n, s) {
    if (typeof n == "function" && (s = n, n = void 0), s === void 0) return tt.sync(t, r, n);
    tt.errback(t, r, n, s);
  }, "transformFromAst");

  W.transformFromAst = du;
  var bu = tt.sync;
  W.transformFromAstSync = bu;
  var gu = tt.async;
  W.transformFromAstAsync = gu;
});
var vo = g(H => {
  "use strict";

  Object.defineProperty(H, "__esModule", {
    value: !0
  });
  H.parseSync = H.parseAsync = H.parse = void 0;

  function yo() {
    let e = __gensync$;
    return yo = o(function () {
      return e;
    }, "_gensync"), e;
  }

  o(yo, "_gensync");

  var mu = _e(),
      hu = rr(),
      yu = Xt(),
      rt = yo()(o(function* (t, r) {
    let n = yield* (0, mu.default)(r);
    return n === null ? null : yield* (0, hu.default)(n.passes, (0, yu.default)(n), t);
  }, "parse")),
      vu = o(function (t, r, n) {
    if (typeof r == "function" && (n = r, r = void 0), n === void 0) return rt.sync(t, r);
    rt.errback(t, r, n);
  }, "parse");

  H.parse = vu;
  var wu = rt.sync;
  H.parseSync = wu;
  var _u = rt.async;
  H.parseAsync = _u;
});
var he = g(b => {
  "use strict";

  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  b.DEFAULT_EXTENSIONS = void 0;
  Object.defineProperty(b, "File", {
    enumerable: !0,
    get: function () {
      return Ou.default;
    }
  });
  b.OptionManager = void 0;
  b.Plugin = Au;
  Object.defineProperty(b, "buildExternalHelpers", {
    enumerable: !0,
    get: function () {
      return Pu.default;
    }
  });
  Object.defineProperty(b, "createConfigItem", {
    enumerable: !0,
    get: function () {
      return q.createConfigItem;
    }
  });
  Object.defineProperty(b, "createConfigItemAsync", {
    enumerable: !0,
    get: function () {
      return q.createConfigItemAsync;
    }
  });
  Object.defineProperty(b, "createConfigItemSync", {
    enumerable: !0,
    get: function () {
      return q.createConfigItemSync;
    }
  });
  Object.defineProperty(b, "getEnv", {
    enumerable: !0,
    get: function () {
      return Eu.getEnv;
    }
  });
  Object.defineProperty(b, "loadOptions", {
    enumerable: !0,
    get: function () {
      return q.loadOptions;
    }
  });
  Object.defineProperty(b, "loadOptionsAsync", {
    enumerable: !0,
    get: function () {
      return q.loadOptionsAsync;
    }
  });
  Object.defineProperty(b, "loadOptionsSync", {
    enumerable: !0,
    get: function () {
      return q.loadOptionsSync;
    }
  });
  Object.defineProperty(b, "loadPartialConfig", {
    enumerable: !0,
    get: function () {
      return q.loadPartialConfig;
    }
  });
  Object.defineProperty(b, "loadPartialConfigAsync", {
    enumerable: !0,
    get: function () {
      return q.loadPartialConfigAsync;
    }
  });
  Object.defineProperty(b, "loadPartialConfigSync", {
    enumerable: !0,
    get: function () {
      return q.loadPartialConfigSync;
    }
  });
  Object.defineProperty(b, "parse", {
    enumerable: !0,
    get: function () {
      return mr.parse;
    }
  });
  Object.defineProperty(b, "parseAsync", {
    enumerable: !0,
    get: function () {
      return mr.parseAsync;
    }
  });
  Object.defineProperty(b, "parseSync", {
    enumerable: !0,
    get: function () {
      return mr.parseSync;
    }
  });
  Object.defineProperty(b, "resolvePlugin", {
    enumerable: !0,
    get: function () {
      return wo.resolvePlugin;
    }
  });
  Object.defineProperty(b, "resolvePreset", {
    enumerable: !0,
    get: function () {
      return wo.resolvePreset;
    }
  });
  Object.defineProperty(b, "template", {
    enumerable: !0,
    get: function () {
      return Eo().default;
    }
  });
  Object.defineProperty(b, "tokTypes", {
    enumerable: !0,
    get: function () {
      return Oo().tokTypes;
    }
  });
  Object.defineProperty(b, "transform", {
    enumerable: !0,
    get: function () {
      return dr.transform;
    }
  });
  Object.defineProperty(b, "transformAsync", {
    enumerable: !0,
    get: function () {
      return dr.transformAsync;
    }
  });
  Object.defineProperty(b, "transformFile", {
    enumerable: !0,
    get: function () {
      return br.transformFile;
    }
  });
  Object.defineProperty(b, "transformFileAsync", {
    enumerable: !0,
    get: function () {
      return br.transformFileAsync;
    }
  });
  Object.defineProperty(b, "transformFileSync", {
    enumerable: !0,
    get: function () {
      return br.transformFileSync;
    }
  });
  Object.defineProperty(b, "transformFromAst", {
    enumerable: !0,
    get: function () {
      return gr.transformFromAst;
    }
  });
  Object.defineProperty(b, "transformFromAstAsync", {
    enumerable: !0,
    get: function () {
      return gr.transformFromAstAsync;
    }
  });
  Object.defineProperty(b, "transformFromAstSync", {
    enumerable: !0,
    get: function () {
      return gr.transformFromAstSync;
    }
  });
  Object.defineProperty(b, "transformSync", {
    enumerable: !0,
    get: function () {
      return dr.transformSync;
    }
  });
  Object.defineProperty(b, "traverse", {
    enumerable: !0,
    get: function () {
      return Po().default;
    }
  });
  b.version = b.types = void 0;
  var Ou = Se(),
      Pu = Ar(),
      wo = ne(),
      Eu = pt();

  function _o() {
    let e = ___babel_types$;
    return _o = o(function () {
      return e;
    }, "_types"), e;
  }

  o(_o, "_types");
  Object.defineProperty(b, "types", {
    enumerable: !0,
    get: function () {
      return _o();
    }
  });

  function Oo() {
    let e = ___babel_parser$;
    return Oo = o(function () {
      return e;
    }, "_parser"), e;
  }

  o(Oo, "_parser");

  function Po() {
    let e = ___babel_traverse$;
    return Po = o(function () {
      return e;
    }, "_traverse"), e;
  }

  o(Po, "_traverse");

  function Eo() {
    let e = ___babel_template$;
    return Eo = o(function () {
      return e;
    }, "_template"), e;
  }

  o(Eo, "_template");

  var q = _e(),
      dr = bo(),
      br = go(),
      gr = ho(),
      mr = vo(),
      Cu = "7.18.2";

  b.version = Cu;
  var Su = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  b.DEFAULT_EXTENSIONS = Su;
  var nt = class {
    init(t) {
      return (0, q.loadOptions)(t);
    }

  };
  o(nt, "OptionManager");
  b.OptionManager = nt;

  function Au(e) {
    throw new Error(`The (${e}) Babel 5 plugin is being run with an unsupported Babel version.`);
  }

  o(Au, "Plugin");
});
var Co = hr(he()),
    So = hr(he()),
    {
  __esModule: wl,
  DEFAULT_EXTENSIONS: _l,
  File: Ol,
  OptionManager: Pl,
  Plugin: El,
  buildExternalHelpers: Cl,
  createConfigItem: Sl,
  createConfigItemAsync: Al,
  createConfigItemSync: kl,
  getEnv: jl,
  loadOptions: xl,
  loadOptionsAsync: Fl,
  loadOptionsSync: Ml,
  loadPartialConfig: $l,
  loadPartialConfigAsync: Nl,
  loadPartialConfigSync: Il,
  parse: ql,
  parseAsync: Dl,
  parseSync: Rl,
  resolvePlugin: Tl,
  resolvePreset: Bl,
  template: Ll,
  tokTypes: Ul,
  transform: Wl,
  transformAsync: Hl,
  transformFile: Vl,
  transformFileAsync: Gl,
  transformFileSync: zl,
  transformFromAst: Jl,
  transformFromAstAsync: Yl,
  transformFromAstSync: Kl,
  transformSync: Xl,
  traverse: Ql,
  version: Zl,
  types: ec
} = So,
    {
  default: ku,
  ...ju
} = So,
    tc = Co.default ?? ku ?? ju;
export { _l as DEFAULT_EXTENSIONS, Ol as File, Pl as OptionManager, El as Plugin, wl as __esModule, Cl as buildExternalHelpers, Sl as createConfigItem, Al as createConfigItemAsync, kl as createConfigItemSync, tc as default, jl as getEnv, xl as loadOptions, Fl as loadOptionsAsync, Ml as loadOptionsSync, $l as loadPartialConfig, Nl as loadPartialConfigAsync, Il as loadPartialConfigSync, ql as parse, Dl as parseAsync, Rl as parseSync, Tl as resolvePlugin, Bl as resolvePreset, Ll as template, Ul as tokTypes, Wl as transform, Hl as transformAsync, Vl as transformFile, Gl as transformFileAsync, zl as transformFileSync, Jl as transformFromAst, Yl as transformFromAstAsync, Kl as transformFromAstSync, Xl as transformSync, Ql as traverse, ec as types, Zl as version };